---
layout: page-fullwidth
title:  "Stacks, Queues, and Deques"
subheadline:  "Simple yet fundamental"
header:
  image_halfwidth: top-logo-whiteboard.jpg
breadcrumb: true
runestone: true
teaser: ""
categories:
    - review
---

# Stacks
I'm reminded of those PEZÂ® candy dispensers with the cool little tops... lift the top back and out "pops" a piece of candy from a spring loaded container.
When its empty, you "push" down another pack of candy. The last piece you push in
is the first one to pop out. They never really tasted that good did they?

> A ```stack``` _is a collection of objects that are inserted and
removed according to the last-in, first-out (LIFO) principle._
The addition of new items and the removal of existing items always takes place at the same end.
Therefore newer items are near the top, while older items are near the base.

Another example is a stack of books on a desk. To illustrate,
find a bunch of old textbooks you never read and have for odd sentimental reasons.
Place the books one by one on top of each other. Now start removing them. Notice the order that they are removed is
exactly the reverse of the order that they were placed. Stacks can be used to reverse the order of items and
a useful tool for many more sophisticated data structures and algorithms. Hey you learned something and those
old college textbooks came in handy after all!



Formally, a stack is an abstract data type (ADT) such that an instance S supports the following two methods:

* ```S.push(item):``` Add element to the top of stack S.
* ```S.pop():``` Remove and return the top element from the stack S; an error occurs if the stack is empty.

We may also want additional helper methods:

* ```S.peek():``` Return a reference to the top element of stack S, without removing it; an error occurs if the stack is empty.
* ```S.isEmpty():``` Return True if stack S does not contain any elements.
* ```S.size():``` Returns the number of items on the stack. It needs no parameters and returns an integer.


#### Implement a stack!
In Python we can easily implement a stack by storing its items in a list and using the available append() and pop() methods.
To add an item to the top of the stack, use append(). To retrieve an item from the top of the stack, use pop().

{% include alert info='NOTE: Although we use the Python list class to implement a stack,
a list has additional properties such as adding and removing an item from **arbitrary** positions ie. insert(i, x),  remove(x) which breaks the
abstraction that the stack ADT represents. We are only using the list class to create a public interface that is consistent with a stack ADT.' %}


Let's start coding! Create a stack class in Python below using a list and the append(), pop() methods.

<div class="row">
<div class="small-12 columns" style="font-size: 14px">

{% include _activecode.html id="stack_p1" lang="python" code="
# Problem:
# Create a stack interface in Python

class Stack:
    def __init__(self):


    def push(self, item):


    def pop(self):


    def peek(self):


    def isEmpty(self):


    def size(self):



# Test Cases:
S = Stack()
print(S.isEmpty())
S.push(4)
S.push('dog')
print(S.peek())
S.push(True)
print(S.size())
print(S.isEmpty())
S.push(8.4)
print(S.pop())
print(S.pop())
print(S.size())
" %}

<!-- Errors -->
<div id="errors"></div>
</div>
</div>




How did you do? Here's a solution:

<div class="row">
<div class="small-12 columns" style="font-size: 14px">

{% include _activecode.html id="stack_s1" lang="python" code="
# Problem:
# Create a stack interface in Python

class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop()

    def peek(self):
        return self.items[len(self.items)-1]

    def isEmpty(self):
        return self.items == 0

    def size(self):
        return len(self.items)


# Test Cases:
S = Stack()
print(S.isEmpty())
S.push(4)
S.push('dog')
print(S.peek())
S.push(True)
print(S.size())
print(S.isEmpty())
S.push(8.4)
print(S.pop())
print(S.pop())
print(S.size())
" %}

<!-- Errors -->
<div id="errors"></div>
</div>
</div>

Big O analysis:

Table 1.1 shows the running times for our Stack methods.
The implementations for peek, isEmpty, and size use constant time O(1).
A call to push or pop uses constant time O(1).

The space usage for a stack is O(n).


# Queues




# Deques